#!/usr/bin/env bash

set -euo pipefail

me=${0##*/}
usage="Print the working directory of a window.

Usage:
    $me [ID]

Arguments:
    ID    print directory for window ID
          (default: focused window)
"

usage() {
    printf "%s\n" "$usage"
    exit 0
}

die() {
    printf "%s: line %s: %s\n" "$0" "${BASH_LINENO[0]}" "$*" >&2
    exit 1
}

while getopts ":h" option; do
    case $option in
    h) usage ;;
    *) die "invalid option '$OPTARG'" ;;
    esac
done && shift "$((OPTIND - 1))"

if [[ -v 1 ]]; then
    # A window ID was given, so look at windows in every workspace.
    window_pid=$(
        swaymsg -t get_tree |
            jq -r --argjson id "$1" '.. | select(.pid? and .id? and .id == $id) | .pid'
    )
else
    # No window ID was given, so allow the user to select visible windows.
    window_pid=$(
        swaymsg -t get_tree |
            jq -r '.. | select(.pid? and .visible? and .focused?) | .pid'
    )
fi

# Fallback value, in case no window information or working directory is found.
cwd=$HOME

if [[ -n $window_pid ]]; then
    # Start the child pid search with the current or given window.
    pid=$window_pid

    # What is the direct descendent of the current pid?
    while next_pid=$(pgrep --parent "$pid" | head -n1); do
        # Some child processes don't inherit the working directory of the
        # parent process. If they are encountered, stop looking for children
        # and use whatever pid was found last.
        case $(readlink /proc/"$next_pid"/exe) in
        */wl-copy) break ;;
        esac

        pid=$next_pid
    done

    cwd_link=/proc/"$pid"/cwd

    # The actual working directory is pointed to by the symlink.
    if possible_cwd=$(realpath "$cwd_link" 2>/dev/null); then
        cwd=$possible_cwd
    fi
fi

printf "$cwd"
