#!/usr/bin/env bash

me=$(basename "$0")
usage="Capture screenshot in a variety of ways.

Think (i)mage (cap)ture when typing icap.

Dependencies: imagemagick

Optional Dependencies:
xsel, xrectsel, optipng, exiftran, libcanberra, notification daemon

Usage:
    $me [-h] [-ncao] [-wus]
    [-g geometry] [-q quality] [-d delay_count]
    [-e command] [-D directory] [filename]

Examples:
    # capture a compressed shot of the desktop, quietly
    $me -o

    # select area to capture, shutter, notify, copy to clipboard
    $me -sncoa

    # count to 3 first, then capture current window
    $me -uncoa -d3

    # edit/view the resulting image
    $me -e 'gimp \$f'
    $me -e 'feh \$f'

The first non-option argument is the output filename.
If no filename is given, %Y-%m-%d_%H-%M-%S.\$t will be used.
"

capture_format() {
	local text=$1

	# image properties
	text=${text//\$t/$capture_filetype}
	text=${text//\$p/$capture_size}
	text=${text//\$w/$capture_width}
	text=${text//\$h/$capture_height}
	text=${text//\$c/$capture_coord}
	text=${text//\$l/$capture_left}
	text=${text//\$t/$capture_top}

	# some should only be applied if the file exists
	if [[ -f $capture_file ]]; then
		# full image path
		text=${text//\$f/$capture_file}

		# file name (w/o dir or ext)
		local n=${capture_file##*/}; n=${capture_file%%.*}
		text=${text//\$n/$n}

		# file size (bytes)
		local s=$(stat -c %s "$capture_file")
		text=${text//\$s/$s}
	fi

	# handle any literal '$'
	text=${text//\$\$/\$}

	date +"$text"  # handle date/time on the way out
}

tick_sound=message-new-instant
shutter_sound=camera-shutter

directory=$PWD
delay_count=0
capture_filetype=png
unset verbose
unset capture_quality  # 1 (worst) to 100 (best)
unset use_optimization
unset capture_geometry
unset use_audible_cues
unset notify_on_capture
unset copy_path_to_clipboard

unset OPTIND
while getopts ":D:q:owusg:and:ce:h" option; do
	case $option in
		D) directory=$OPTARG ;;
		q) capture_quality=$OPTARG ;;
		o) use_optimization=1 ;;

		# various ways to define capture region
		w) capture_geometry=$(xwinrect -frame -id "$(xprop-selected-window)") ;;
		u) capture_geometry=$(xwinrect -frame -id "$(xprop-active-window)") ;;
		s) capture_geometry=$(xrectsel) ;;  # TODO: dependency hurdle
		g) capture_geometry=$OPTARG ;;

		# might be suitable for another tool
		a) use_audible_cues=1 ;;
		n) notify_on_capture=1 ;;
		d) delay_count=$OPTARG ;;
		c) copy_path_to_clipboard=1 ;;

		# run commands after capture
		e) exec_command=$OPTARG ;;

		h) echo "$usage" >&2; exit 0 ;;
		*) echo "$usage" >&2; exit 1 ;;
	esac
done && shift $((OPTIND - 1))

# this isn't accurate when using multiple displays.
# it gives the total of all displays, instead of the current one
root_geometry=$(xwinrect -root)

# image properties (mostly for formatting)
if [[ -z $capture_geometry ]]; then
	capture_geometry=$root_geometry
fi
capture_size=${capture_geometry%%+*}
capture_width=${capture_size%x*}
capture_height=${capture_size#*x}
c=${capture_geometry#*+}
capture_coord=+$c
capture_left=${c%+*}
capture_top=${c#*+}

# if image isn't given as $1, then
# use a default filename that sorts chronologically
capture_file=${1:-$directory/%Y-%m-%d_%H-%M-%S.\$t}

# format image properties, etc
capture_file=$(capture_format "$capture_file")

# options for imagemagick
import_options=(-window root)
[[ -n $capture_geometry ]] && import_options+=(-crop "$capture_geometry")
[[ -n $capture_quality ]] && import_options+=(-quality "$capture_quality")

# some tools output a ton of garbage.
# if debugging, comment out these braces
{

	if [[ -n $use_audible_cues ]]; then
		for (( tick=1; tick <= delay_count; tick+=1 )); do
			canberra-gtk-play -i $tick_sound
		done
	fi

	rm -f "$capture_file"
	mkdir -p "$(dirname "$capture_file")"

	import "${import_options[@]}" "$capture_file"

	if [[ ! -f $capture_file ]]; then
		notify-send -u critical "screenshot capture failed"
		exit 1
	fi

	if [[ -n $use_optimization ]]; then
		case $capture_file in
			*.png) optipng "$capture_file" ;;
			*.jpg) jpegtran -optimize -copy none "$capture_file" ;;
		esac
	fi

	capture_file=$(readlink -f "$capture_file")

	if [[ -n $copy_path_to_clipboard ]]; then
		echo -n "$capture_file" | xsel -ib
	fi

	if [[ -n $notify_on_capture ]]; then
		fs=$(du -h "$capture_file" | cut -f1)
		info="<u>${capture_file/$HOME/\~}</u>, $fs, $capture_size"
		notify-send "screenshot captured" "$info"
	fi

	if [[ -n $use_audible_cues ]]; then
		canberra-gtk-play -i $shutter_sound
	fi

} >/dev/null 2>&1

echo -n "$capture_file"

if [[ -n $exec_command ]]; then
	exec "$(capture_format "$exec_command")"
fi
