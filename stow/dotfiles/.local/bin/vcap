#!/usr/bin/env bash

me=$(basename $0)
usage="Capture camera activity in a variety of ways.

Think (v)ideo (cap)ture when typing vcap.

Dependencies: ffmpeg

Optional Dependencies:
xsel, gifsicle, libcanberra, notification daemon

Usage:
    $me [-h] [-ncaox]
    [-s size] [-q quality] [-r framerate]
    [-t seconds] [-d delay_count] [-l loop_count]
    [-e command] [-D directory] [filename]

Examples:
    # capture a compressed recording
    $me -o

    # end recording (if in background, ctrl-c otherwise)
    $me -x

    # capture, notify, copy to clipboard
    $me -nco

    # count to 3 first
    $me -d3

The first non-option argument is the output filename.
If no filename is given, %Y-%m-%d_%H-%M-%S.gif will be used.
"

capture_format() {
    local text=$1

    # recording properties
    text=${text//\$t/$capture_filetype}
    text=${text//\$p/$capture_size}
    text=${text//\$w/$capture_width}
    text=${text//\$h/$capture_height}

    # some should only be applied if the file exists
    if [[ -f $capture_file ]]; then
        # full image path
        text=${text//\$f/$capture_file}

        # file name (w/o dir or ext)
        local n=${capture_file##*/}; n=${capture_file%%.*}
        text=${text//\$n/$n}

        # file size (bytes)
        local s=$(stat -c %s "$capture_file")
        text=${text//\$s/$s}
    fi

    # handle any literal '$'
    text=${text//\$\$/\$}

    date +"$text"  # handle date/time on the way out
}

stop_recording() {
    killall -INT ffmpeg >/dev/null 2>&1
}

shutter_sound=camera-shutter
start_sound=bell
tick_sound=message-new-instant

directory=$PWD
delay_count=0
capture_filetype=gif
capture_framerate=25
capture_quality=1  # 1 (best) to 31 (worst)
unset use_optimization
unset capture_seconds
unset use_audible_cues
unset notify_on_capture
unset copy_path_to_clipboard

unset OPTIND
while getopts ":D:t:r:q:os:and:b:ce:xh" option; do
    case $option in
        D) directory=$OPTARG ;;
        t) capture_seconds=$OPTARG ;;
        r) capture_framerate=$OPTARG ;;
        q) capture_quality=$OPTARG ;;
        o) use_optimization=1 ;;
        s) capture_size=$OPTARG ;;

        # might be suitable for another tool
        a) use_audible_cues=1 ;;
        n) notify_on_capture=1 ;;
        d) delay_count=$OPTARG ;;
        b) capture_count=$OPTARG ;;
        c) copy_path_to_clipboard=1 ;;

        # run commands after capture
        e) exec_command=$OPTARG ;;

        x) stop_recording; exit 0 ;;

        *) echo "$usage" >&2; exit 1 ;;
        h) echo "$usage" >&2; exit 0 ;;
    esac
done && shift $(($OPTIND - 1))

if [[ -z $capture_size ]]; then
    capture_size=$(
        v4l2-ctl --list-formats-ext |
        grep "\bSize:" | cut -d' ' -f3 | head -n1
    )
fi
capture_width=${capture_size%x*}
capture_height=${capture_size#*x}

# if image isn't given as $1, then
# use a default filename that sorts chronologically
capture_file=${1:-$directory/%Y-%m-%d_%H-%M-%S.\$t}

# format capture properties, etc
capture_file=$(capture_format "$capture_file")

capture_options="-y -f v4l2"
capture_options+=" -framerate $capture_framerate"
capture_options+=" -video_size $capture_size"
capture_options+=" -i /dev/video0"

case $capture_filetype in
    gif) capture_options+=" -pix_fmt rgb24" ;;
    jpg|png) capture_options+=" -vframes 1" ;;
    *) capture_options+=" -c:v libx264" ;;
esac

# optimizations for hq output
capture_options+=" -qscale $capture_quality -threads 0"

# if no time, ctrl-c to stop
if [[ -n $capture_seconds ]]; then
    capture_options+=" -t $capture_seconds"
fi

# some tools output a ton of garbage.
# if debugging, comment out these braces
{

    if [[ -n $use_audible_cues ]]; then
        canberra-gtk-play -i $start_sound
        for (( tick=1; $tick <= $delay_count; tick+=1 )); do
            canberra-gtk-play -i $tick_sound
        done
    fi

    rm -f "$capture_file"
    mkdir -p "$(dirname "$capture_file")"

    ffmpeg $capture_options "$capture_file"

    if [[ ! -f $capture_file ]]; then
        notify-send -u critical "recording failed"
        exit 1
    fi

    if [[ -n $use_optimization ]]; then
        case $capture_file in
            *.png) optipng "$capture_file" ;;
            *.jpg) jpegtran -optimize -copy none "$capture_file" ;;
            *.gif) gifsicle --batch --optimize=3 "$capture_file" ;;
        esac
    fi
    capture_file=$(readlink -f "$capture_file")

    if [[ -n $copy_path_to_clipboard ]]; then
        echo -n "$capture_file" | xsel -ib
    fi

    if [[ -n $notify_on_capture ]]; then
        fs=$(du -h "$capture_file" | cut -f1)
        info="<u>${capture_file/$HOME/\~}</u>, $fs, $capture_size"
        notify-send "camera activity captured" "$info"
    fi

    if [[ -n $use_audible_cues ]]; then
        canberra-gtk-play -i $shutter_sound
    fi

} >/dev/null 2>&1

echo -n "$capture_file"

if [[ -n $exec_command ]]; then
    exec $(capture_format "$exec_command")
fi
