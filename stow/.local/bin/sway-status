#!/usr/bin/env python3

import locale
import time
import json
import signal
import os
import subprocess
from pathlib import Path


color_off = "#4c4c4c"

data_sizes_in_bytes = {}
data_size_symbols = "BKMGTPEZY"
for i, s in enumerate(data_size_symbols[1:]):
    data_sizes_in_bytes[s] = 1 << (i + 1) * 10


def bytes2human(value, fmt="{value:.1f} {symbol}"):
    for symbol in reversed(data_size_symbols[1:]):
        if value >= data_sizes_in_bytes[symbol]:
            value = value / data_sizes_in_bytes[symbol]
            return fmt.format(symbol=symbol, value=value)
    return fmt.format(symbol=data_size_symbols[0], value=value)


def capture_stdout(command):
    cp = subprocess.run(command, capture_output=True, text=True)
    cp.check_returncode()
    return cp.stdout


def capture_stdout_lines(command):
    return capture_stdout(command).strip().split(os.linesep)


class Element:
    def create_block(self, full_text, **kwargs):
        kwargs["name"] = self.__class__.__name__
        kwargs["full_text"] = full_text
        return kwargs

    def update(self, output):
        raise NotImplementedError


class PathExists(Element):
    def __init__(self, path, label=None):
        self.path = path
        self.label = label or path.name

    def update(self, output):
        if self.path.exists():
            output.append(
                self.create_block(self.label, instance=str(self.path))
            )


class Clock(Element):
    def __init__(self, full_format="%c", short_format="%r"):
        self.full_format = full_format
        self.short_format = short_format

    def update(self, output):
        kwargs = {}
        if self.short_format:
            kwargs["short_text"] = time.strftime(self.short_format)
        full_text = time.strftime(self.full_format)
        output.append(self.create_block(full_text, **kwargs))


class DiskUsage(Element):
    def __init__(self, path, label=None):
        self.path = os.path.expanduser(path)
        self.label = label or path.replace(os.path.expanduser("~"), "~")

    def update(self, output):
        stat = os.statvfs(self.path)
        free = stat.f_frsize * stat.f_bfree
        full_text = f"{self.label} {bytes2human(free)}"
        output.append(self.create_block(full_text, instance=self.path))


class MemoryInfo(Element):
    source = "/proc/meminfo"

    def __init__(self, key="MemAvailable"):
        self.line_number = self._find_line_number(key)

    def _find_line_number(self, key):
        line_number = 0

        for line in open(self.source).readlines():
            if line.startswith(key + ":"):
                return line_number
            line_number += 1

        raise KeyError(f"Key '{key}' not found in {self.source}")

    def update(self, output):
        line = open(self.source).readlines()[self.line_number]
        free = int(line.split(":")[1].strip().split()[0]) * 1024
        output.append(self.create_block(f"mem {bytes2human(free)}"))


class NetworkInterfaces(Element):
    def __init__(self):
        self.sys_path = Path("/sys/class/net")

    def update(self, output):
        for interface_path in self.sys_path.glob("*"):
            if open(interface_path / "operstate").read().strip() == "up":
                name = interface_path.name
                output.append(self.create_block(f"{name}", instance=name))


class Mullvad(PathExists):
    def __init__(self):
        super().__init__(
            Path("/proc/sys/net/ipv4/conf/wg-mullvad"), label="vpn"
        )


class LoadAverage(Element):
    def __init__(self):
        self.file = "/proc/loadavg"

    def update(self, output):
        loadavg = " ".join(open(self.file).read().split()[:-1])
        output.append(self.create_block(f"load {loadavg}"))


class Batteries(Element):
    def __init__(self):
        self.batteries = list(Path("/sys/class/power_supply").glob("BAT*"))

    def update(self, output):
        for battery in self.batteries:
            battery_name = battery.name.lower()
            battery_status = open(battery / "status").read().strip().lower()
            battery_capacity = open(battery / "capacity").read().strip()
            full_text = f"{battery_name} {battery_capacity}% {battery_status}"
            output.append(self.create_block(full_text, instance=battery_name))


class PulseAudio(Element):
    def __init__(self, sink="@DEFAULT_SINK@"):
        self.sink = sink

    @property
    def stereo_volume(self):
        stdout = capture_stdout(["pactl", "get-sink-volume", self.sink])
        return [
            int(s.strip().rstrip("%"))
            for s in stdout.split(" / ")
            if s.endswith("%")
        ]

    @property
    def volume_text(self):
        volumes = self.stereo_volume
        volume_format = "{}%"
        if len(set(volumes)) == 1:
            return volume_format.format(volumes[0])
        else:
            return " / ".join([volume_format.format(v) for v in volumes])

    @property
    def muted(self):
        stdout = capture_stdout(["pactl", "get-sink-mute", self.sink])
        return stdout.split()[1] == "yes"

    def update(self, output):
        try:
            kwargs = {}
            if self.muted:
                kwargs["color"] = color_off
            output.append(
                self.create_block(f"audio {self.volume_text}", **kwargs)
            )
        except subprocess.CalledProcessError:
            return


class MediaPlayer(Element):
    def __init__(self, format="{{lc(status)}} <u>{{title}}</u>"):
        self.format = format

    def update(self, output):
        try:
            full_text = capture_stdout(
                ["playerctl", "metadata", "--format", self.format]
            ).strip()
        except subprocess.CalledProcessError:
            return

        if full_text:
            output.append(
                self.create_block(
                    full_text,
                    short_text=full_text.split(":")[0],
                    markup="pango",
                )
            )


class StatusUpdater:
    def __init__(self, elements):
        self.elements = elements

    def _send_line(self, line):
        print(line, flush=True)

    def _send_header(self):
        self._send_line(
            json.dumps(
                {
                    "version": 1,
                    "click_events": False,
                    "stop_signal": signal.SIGTSTP,
                }
            )
        )

    def _send_update(self):
        output = []
        for element in self.elements:
            element.update(output)
        self._send_line("," + json.dumps(output))

    def run(self):
        self._send_header()
        self._send_line("[[]")

        while True:
            self._send_update()
            time.sleep(1)


def main():
    locale.setlocale(locale.LC_ALL, "")

    elements = [
        NetworkInterfaces(),
        Mullvad(),
        LoadAverage(),
        DiskUsage("~"),
        MemoryInfo(),
        Batteries(),
        PulseAudio(),
        MediaPlayer(),
        Clock(),
    ]

    StatusUpdater(elements).run()


if __name__ == "__main__":
    main()
