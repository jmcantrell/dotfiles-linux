#!/usr/bin/env bash

set -e

# Default options:
delay=0                    # skip countdown
geometry=$(xwinrect -root) # entire desktop

me=${0##*/}
usage="Capture motion from the screen.

Usage: $me [-h] [-x] [-wus] [-m NUMBER|centered]
       [-g GEOMETRY] [-d NUMBER] [-t NUMBER] FILENAME
    
Options:
    -h             show this help message
    -x             stop recording
    -w             click to select a window to capture
    -u             capture the current window
    -s             drag to select a region to capture
    -m NUMBER      drag to size a viewport that follows the mouse
    -g GEOMETRY    restrict capture to GEOMETRY (default: $geometry)
    -d NUMBER      delay each capture by NUMBER seconds (default: $delay)
    -t NUMBER      capture for NUMBER seconds (default: record indefinitely)

Arguments:
    FILENAME       output capture to FILENAME

Examples:
    $me desktop.mp4
        Capture a video of the desktop (including microphone input).

    $me -w window.gif
        Capture an animated gif of the selected window.

    $me -m50 region.gif
        Define a viewport, then follow the mouse with a fifty pixel padding.

The output filename can include any format sequence accepted by date(1).
"

pidfile=${XDG_CACHE_HOME:-$HOME/.cache}/$me/pid

usage() {
    echo "$usage" >&2
    exit 0
}

die() {
    echo "$me: $*" >&2
    exit 1
}

stop_recording() {
    [[ -f $pidfile ]] || die "nothing is recording"
    pkill -INT -P "$(<"$pidfile")" ffmpeg
    exit 0
}

unset OPTIND
while getopts ":hwusg:m:d:t:x" option; do
    case $option in
    h) usage ;;

    w) geometry=$(xwinrect -id "$(selected-window)") ;;
    u) geometry=$(xwinrect -id "$(active-window)") ;;
    s) geometry=$(xrectsel) ;;
    g) geometry=$OPTARG ;;

    # Region follows when $OPTARG pixels from edge.
    # These have the same result: -m centered, -m 999999999
    m)
        follow_mouse=1
        geometry=$(xrectsel)
        pixels_from_edge=$OPTARG
        ;;

    d) delay=$OPTARG ;;
    t) duration=$OPTARG ;;

    x) stop_recording ;;

    *) die "invalid option '$option'" ;;
    esac
done && shift $((OPTIND - 1))

output=$1

# Ensure options and arguments are valid:
[[ $output ]] || die "missing output file"
((delay >= 0)) || die "delay must be a non-negative number"

# Convert path from relative to absolute:
output=$(realpath "$output")

# Substitute date format sequences:
output=$(date +"$output")

# Ensure file can be written:
mkdir -p "$(dirname "$output")"

# Parse geometry string:
size=${geometry%%+*}
top_left=${geometry#*+}
left=${top_left%+*}
top=${top_left#*+}

# Set up options for capture:
options=(-y -f x11grab -s "$size" -i "${DISPLAY}+${left%+*},${top#*+}")
[[ $follow_mouse ]] && options+=(-follow_mouse "${pixels_from_edge}")
options+=(-f alsa -i default)
[[ $duration ]] && options+=(-t "$duration")

# If requested, do an audible countdown:
if ((delay > 0)); then
    for ((tick = 1; tick <= delay; tick += 1)); do
        canberra-gtk-play -i message-new-instant &
        sleep 1
    done
fi

# Set up the pid file, so the capture can be stopped externally:
mkdir -p "$(dirname "$pidfile")"
echo "$$" >"$pidfile"
trap "rm -f $(printf "%q" "$pidfile")" INT TERM EXIT

# Perform the capture:
ffmpeg "${options[@]}" "$output"
optimize-images "$output"
canberra-gtk-play -i camera-shutter &

# Output the full path:
echo "$output"              # stdout
printf "%q" "$output" | cbi # clipboard

# Let the user know that result is ready:
notify-send -i media-record "Captured Screencast" "<u>${output/$HOME/\~}</u>" &

# Open file for review:
xdg-open "$output" &
