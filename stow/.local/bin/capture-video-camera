#!/usr/bin/env bash

set -eu

delay=0
device=/dev/video0
directory=$HOME
file_name=camera_%FT%T%:z
file_type=mp4

me=${0##*/}
usage="Capture video from a camera device.

Usage:
    $me [OPTIONS] [FILE | 'stop']
    
Options:
    -a              also capture audio from microphone

    -i DEVICE       capture input from device
                    (default: $device)

    -d NUMBER       number of seconds to wait before starting capture
                    (default: $delay)

    -D DIRECTORY    directory in which to store default output file
                    (default: $directory)

    -N FILENAME     filename to use for default output file
                    (default: $file_name)

    -E EXTENSION    extension to use for default output file
                    (default: $file_type)

Arguments:
    FILE            output file (used instead of default)
                    formats any sequences recognized by strftime
                    (default: $directory/$file_name.$file_type)

    'stop'          stop recording session
"

usage() {
    printf "%s\n" "$usage"
    exit 0
}

die() {
    printf "ERROR: %s\n" "$*" >&2
    exit 1
}

while getopts ":ai:d:D:N:E:h" option; do
    case $option in
    a) capture_audio=1 ;;
    i) device=$OPTARG ;;
    d) delay=$OPTARG ;;
    D) directory=$OPTARG ;;
    N) file_name=$OPTARG ;;
    E) file_type=$OPTARG ;;
    h) usage ;;
    *) die "Invalid option '$OPTARG'" ;;
    esac
done && shift $((OPTIND - 1))

capture_command_stdin=$XDG_RUNTIME_DIR/$me-command.stdin

if [[ -v 1 && $1 == stop ]]; then
    if [[ -f $capture_command_stdin ]]; then
        printf "q\n" >>"$capture_command_stdin"
    fi
    exit 0
fi

output_file=$(date +"${1:-$directory/$file_name.$file_type}")

capture_command=(ffmpeg -hide_banner -loglevel error -y -f v4l2 -i "$device")

if [[ -v capture_audio ]]; then
    capture_command+=(-f alsa -i default)
fi

if [[ -v duration ]]; then
    capture_command+=(-t "$duration")
fi

if ((delay > 0)); then
    canberra-gtk-play -l "$delay" -i message
fi

mkdir -p "$(dirname "$output_file")"
capture_command+=("$output_file")

# If not connected to a TTY, tell ffmpeg to get its stdin from a runtime file.
# This way, recording can be stopped remotely by writing 'q' to the file.
# For this script, a shortcut is to give "stop" as the first argument.

if ! tty -s; then
    touch "$capture_command_stdin"
    trap 'rm -f "$capture_command_stdin"' INT TERM EXIT
    "${capture_command[@]}" <"$capture_command_stdin"
else
    printf "Press 'q' at any time to stop recording...\n"
    "${capture_command[@]}"
fi

if [[ $output_file == *.gif ]]; then
    gifsicle --batch --optimize=3 "$output_file"
fi

canberra-gtk-play -i screen-capture &

notify-send -i media-record \
    "Captured camera video${capture_audio:+ (with audio)}:" \
    "<u>${output_file##*/}</u>" &

wl-copy -n "$output_file"
