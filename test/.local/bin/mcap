#!/usr/bin/env bash

me=$(basename "$0")
usage="Capture screencast in a variety of ways.

Think (m)otion (cap)ture when typing mcap.

Dependencies: ffmpeg

Optional Dependencies:
xsel, xrectsel, gifsicle, libcanberra, notification daemon

Usage:
    $me [-h] [-ncaox] [-wus] [-m pixels-from-edge]
    [-g geometry] [-q video-quality] [-r framerate] [-t seconds]
    [-d delay_count] [-e command] [-D directory] [filename]

Examples:
    # capture a recording of the desktop
    $me

    # end recording (if in background, ctrl-c otherwise)
    $me -x

    # select area to capture, notify, copy to clipboard
    $me -snc

    # count to 3 first, then capture current window
    $me -unc -d3

	# open the resulting file
    $me -o

    # execute a command for the resulting image
    $me -e 'mplayer \$f'

The first non-option argument is the output filename.
If no filename is given, %Y-%m-%d_%H-%M-%S.gif will be used.
"

capture_format() {
	local text=$1

	# recording properties
	text=${text//\$t/$capture_filetype}
	text=${text//\$p/$capture_size}
	text=${text//\$w/$capture_width}
	text=${text//\$h/$capture_height}
	text=${text//\$c/$capture_coord}
	text=${text//\$l/$capture_left}
	text=${text//\$t/$capture_top}

	# some should only be applied if the file exists
	if [[ -f $capture_file ]]; then
		# full image path
		text=${text//\$f/$capture_file}

		# file name (w/o dir or ext)
		local n=${capture_file##*/}; n=${capture_file%%.*}
		text=${text//\$n/$n}

		# file size (bytes)
		local s=$(stat -c %s "$capture_file")
		text=${text//\$s/$s}
	fi

	# handle any literal '$'
	text=${text//\$\$/\$}

	date +"$text"  # handle date/time on the way out
}

stop_recording() {
	killall -INT ffmpeg >/dev/null 2>&1
}

has() {
	which "$1" &>/dev/null
}

shutter_sound=camera-shutter
start_sound=bell
tick_sound=message-new-instant

directory=$PWD
delay_count=0
capture_filetype=gif
video_quality=1  # 1 (best) to 31 (worst)
unset capture_seconds
unset capture_geometry
unset capture_follows_mouse
unset use_audible_cues
unset notify_on_capture
unset open_after_capture
unset copy_path_to_clipboard

unset OPTIND
while getopts ":D:t:r:q:og:wusm:and:ce:xh" option; do
	case $option in
		D) directory=$OPTARG ;;
		t) capture_seconds=$OPTARG ;;
		r) capture_framerate=$OPTARG ;;
		q) video_quality=$OPTARG ;;

		# various ways to define capture region
		g) capture_geometry=$OPTARG ;;
		w) capture_geometry=$(xwinrect -id "$(selected-window)") ;;
		u) capture_geometry=$(xwinrect -id "$(active-window)") ;;
		s|m) capture_geometry=$(xrectsel) ;;&

		# region follows when $OPTARG pixels from edge
		# same result: -m centered, -m 999999999
		m) capture_follows_mouse=1; pixels_from_edge=$OPTARG ;;

		# might be suitable for another tool
		a) use_audible_cues=1 ;;
		n) notify_on_capture=1 ;;
		o) open_after_capture=1 ;;
		d) delay_count=$OPTARG ;;
		c) copy_path_to_clipboard=1 ;;

		# run commands after capture
		e) exec_command=$OPTARG ;;

		x) stop_recording; exit 0 ;;

		h) echo "$usage" >&2; exit 0 ;;
		*) echo "$usage" >&2; exit 1 ;;
	esac
done && shift $((OPTIND - 1))

# this isn't accurate when using multiple displays.
# it gives the total of all displays, instead of the current one
root_geometry=$(xwinrect -root)
# image properties (mostly for formatting)
if [[ ! $capture_geometry ]]; then
	capture_geometry=$root_geometry
fi
capture_size=${capture_geometry%%+*}
capture_width=${capture_size%x*}
capture_height=${capture_size#*x}
c=${capture_geometry#*+}
capture_coord=+$c
capture_left=${c%+*}
capture_top=${c#*+}

capture_options=(-y -f x11grab)
if [[ $capture_follows_mouse ]]; then
	capture_options+=(-follow_mouse "${pixels_from_edge}")
fi
capture_options+=(-r "${capture_framerate:-8}" -s "$capture_size")
capture_options+=(-i "${DISPLAY}+${capture_left},${capture_top}")

# if image isn't given as $1, then
# use a default filename that sorts chronologically
capture_file=${1:-$directory/%Y-%m-%d_%H-%M-%S.\$t}

# format capture properties, etc
capture_file=$(capture_format "$capture_file")

case $capture_filetype in
	gif) capture_options+=(-pix_fmt rgb8) ;;
	*) capture_options+=(-c:v libx264) ;;
esac

# optimizations for hq output
capture_options+=(-q:v "$video_quality" -threads 0)

# if no time, ctrl-c to stop
if [[ -n $capture_seconds ]]; then
	capture_options+=(-t "$capture_seconds")
fi

if [[ -n $use_audible_cues ]]; then
	canberra-gtk-play -i $start_sound
	for (( tick=1; tick <= delay_count; tick+=1 )); do
		canberra-gtk-play -i $tick_sound
	done
fi

rm -f "$capture_file"
mkdir -p "$(dirname "$capture_file")"

ffmpeg "${capture_options[@]}" "$capture_file"

if [[ ! -f $capture_file ]]; then
	notify-send -u critical "screencast recording failed"
	exit 1
fi

case $capture_file in
	*.gif) has gifsicle && gifsicle --batch --optimize=3 "$capture_file" ;;
esac

capture_file=$(readlink -f "$capture_file")

if [[ -n $copy_path_to_clipboard ]]; then
	echo -n "$capture_file" | xsel -ib
fi

if [[ -n $notify_on_capture ]]; then
	fs=$(du -h "$capture_file" | cut -f1)
	info="<u>${capture_file/$HOME/\~}</u>, $fs, $capture_size"
	notify-send "screencast captured" "$info"
fi

if [[ -n $use_audible_cues ]]; then
	canberra-gtk-play -i $shutter_sound
fi

echo -n "$capture_file"

if [[ -n $exec_command ]]; then
	exec "$(capture_format "$exec_command")"
fi

if [[ -n $open_after_capture ]]; then
	xdg-open "$capture_file"
fi
